<!--
 * @Description: 
 * @version: 
 * @Author: Wang
 * @Date: 2021-12-29 16:36:18
 * @LastEditors: Andy
 * @LastEditTime: 2021-12-30 16:45:16
-->

# 红黑树

性质：

1. 每个节点要要么是黑色要么是红色
2. 根节点是黑色
3. 每个叶子结点是黑色
4. 每个叶子节点的两个子节点一定是黑色，不能有两个红色节点相连
5. 任意一个结点到叶子结点的所有路径都包括数量相同的黑色结点

红黑树自平衡操作：变色、左旋、右旋

- 变色：红变黑，黑变红
- 左旋：以某个节点作为支点（旋转节点），其右子节点变为旋转节点的父节点，右子节点的左子节点变为旋转节点的右子节点，左子节点保持不变
- 右旋：以某个节点作为支点（旋转节点），其左子节点变为旋转节点的父节点，左子节点的右子节点变为旋转节点的左子节点，右子节点保持不变

插入：

1. 查找插入的位置
2. 插入后进行自平衡

==插入的节点一定是红色插入==

> 情况一：插入的树是空树

直接插入节点作为根节点，同时进行变色，将红色变为黑色

> 情况二：要插入的key已经存在

更新当前节点的值为插入节点的值

> 情况三：插入位置的父节点为黑色

由于插入的节点为红色，当要插入位置的父节点为黑色时并不会影响红黑树的平衡，直接插入即可，无需自平衡

> 情况四：插入位置的父节点为红色

此时由于父节点为红色，所以一定存在黑色的爷爷节点。

这种可以细分为叔叔节点存在，且为红色，以及叔叔节点不存在，或存在为黑色，这时又分为父节点在左和在右两种情况，一共三种情况。

> 情况4.1：叔叔节点存在，并且为红色

将爸爸、叔叔节点变色为黑色节点，爷爷节点变色为红色节点，然后将爷爷节点设置为当前节点，继续判断并操作（递归的方式不断修改）

> 情况4.2：叔叔节点不存在，或叔叔节点为黑色，叔叔节点为爷爷节点的右节点

插入的位置有可能是左侧也有可能是在右侧

> 情况4.2.1：在情况4.2的基础上，插入的位置为左侧

处理：

1. 首先将父节点变色为黑色，爷爷节点变色为红色
2. 以爷爷节点为旋转节点，进行右旋（左节点变为父节点，左节点的右子树变为旋转节点的左子树）

> 情况4.2.2: 在情况4.2的基础上插入的位置为右侧

处理：

1. 以父节点为旋转节点，进行左旋（右子节点变为父节点，右子节点的左子节点变为旋转节点的柚子节点）
2. 将之前的父节点设置为当前节点，得到了父节点为红色，当前节点为红色，并且当前节点位于父节点的左侧
3. 按照4.2.1的处理进行处理（1.爷爷变红，父亲变黑 2.以爷爷为旋转节点进行右旋）

> 情况4.3：叔叔节点不存在，或叔叔节点为黑色，叔叔节点为爷爷节点的左节点

对应情况4.2，为4.2的反方向

> 4.3.1: 新插入节点为父节点的右子节点

处理：

1. 变色将父节点设置为黑色，爷爷节点设置为红色
2. 根据爷爷节点为旋转节点，进行左旋（右变父，右左变右）

> 情况4.3.2: 新插入节点为父节点的左子节点

处理：

1. 以父节点为旋转节点，进行右旋（左变父，左右变左）
2. 将之前的父节点设置为当前节点，得到了父节点为红色，当前节点为红色，并且当前节点位于父节点的右侧
3. 按照4.3.1的处理进行处理（1.爷爷变红，父亲变黑 2.以爷爷为旋转节点进行左旋）
